
/*****************************************************************************/
/*                              Legal                                        */
/*****************************************************************************/

/*
** Copyright �2017-2018. Lantronix, Inc. All Rights Reserved.
** By using this software, you are agreeing to the terms of the Software
** Development Kit (SDK) License Agreement included in the distribution package
** for this software (the �License Agreement�).
** Under the License Agreement, this software may be used solely to create
** custom applications for use on the Lantronix xPico 250 product.
** THIS SOFTWARE AND ANY ACCOMPANYING DOCUMENTATION IS PROVIDED "AS IS".
** LANTRONIX SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED
** TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS
** FOR A PARTICULAR PURPOSE.
** LANTRONIX HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
** ENHANCEMENTS, OR MODIFICATIONS TO THIS SOFTWARE.
** IN NO EVENT SHALL LANTRONIX BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
** SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
** ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
** LANTRONIX HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/



/*****************************************************************************/
/*                             Includes                                      */
/*****************************************************************************/

#include <stdio.h>
#include <string.h>

#include "wiced_bt_ble.h"
#include "wiced_bt_gatt.h"
#include "wiced_bt_cfg.h"
#include "bt_target.h"
#include "wiced_bt_stack.h"
#include "gattdefs.h"
#include "sdpdefs.h"
#include "bleSensor.h"
#include "restApi.h"
#include "message_queue.h"

#include "ltrx_bt_essential.h"

#include "ltrx_compile_defines.h" /* Delivered with SDK. */
#include "ltrx_cpm.h"  /* Delivered with SDK. */
#include "ltrx_definitions.h"  /* Delivered with SDK. */
#include "ltrx_network.h"  /* Delivered with SDK. */
#include "ltrx_stream.h"  /* Delivered with SDK. */
#include "ltrx_tlog.h"  /* Delivered with SDK. */
#include "ltrx_http.h"
#include "message_queue.h"

#include "bleSensor_module_defs.h" /* Automatically generated by make. */


/******************************************************************************
 *                                Constants                                   *
******************************************************************************/

#define BLE_WIFI_INT_STACK_USED             10000
#define SCAN_WAIT_INTERVAL                  20000
#define BT_HEADER_SIZE                      3
#define HEART_RATE_SERVICE_GATT_UUID        0x180D
#define HEART_RATE_CHAR_UUID                0x2A37
#define CLIENT_CONFIG_CHAR_UUID             0x2902

/*****************************************************************************/
/*                             Globals                                       */
/*****************************************************************************/

struct bleSensor_module_data* g_bluetooth_data;

ble_device_data s_bleScanResults[MAX_DEVICE_DISCOVER];
struct message_queue* ble_queue;
struct ltrx_trigger ble_queue_trigger;

/******************************************************************************
 *                           Function Prototypes
 ******************************************************************************/


void bleSensor_start(void);
bool bleSensor_thread_init( void );
static void bt_thread_func(void *arg);
static wiced_bt_gatt_status_t ble_gatt_event_callback(wiced_bt_gatt_evt_t event, wiced_bt_gatt_event_data_t *p_event_data);

/******************************************************************************
 *                                Variables Definitions
 ******************************************************************************/

extern const wiced_bt_cfg_settings_t    wiced_bt_cfg_settings;
extern const wiced_bt_cfg_buf_pool_t    wiced_bt_cfg_buf_pools[];


static bool s_isBtEnabled = false;


/******************************************************************************
 *                          Function Definitions
 ******************************************************************************/

 void bleSensor_start(void)
{
    bool status = false;

    g_bluetooth_data = MALLOC_ZEROED(sizeof(*g_bluetooth_data));
    if(! g_bluetooth_data)
    {
        return;
    }

    status = bleSensor_thread_init();
    if(!status)
    {
        TLOG(TLOG_SEVERITY_LEVEL__ERROR, "Bluetooth failed initialization");
    }
}

/* Bluetooth management event handler */
static wiced_bt_dev_status_t ble_gateway_management_callback( wiced_bt_management_evt_t event, wiced_bt_management_evt_data_t *p_event_data )
{
    wiced_bt_dev_status_t status = WICED_BT_SUCCESS;

    switch ( event )
    {
        case BTM_ENABLED_EVT:
            if ( p_event_data->enabled.status == WICED_BT_SUCCESS )
            {
                wiced_bt_set_local_bdaddr( g_bluetooth_data->dev_info.dev_mac );
                TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "BTM Enabled");
								wiced_bt_gatt_register( ble_gatt_event_callback );

                /* Enable proximity reporter */
                //ble_proximity_reporter_init( );
            }
            break;

        case BTM_SECURITY_REQUEST_EVT:
            wiced_bt_ble_security_grant( p_event_data->security_request.bd_addr, WICED_BT_SUCCESS );
            TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "BTM Security Request");
            break;

        case BTM_PAIRING_IO_CAPABILITIES_BLE_REQUEST_EVT:
            p_event_data->pairing_io_capabilities_ble_request.local_io_cap = BTM_IO_CAPABILITIES_NONE; /* No IO capabilities on this platform */
            p_event_data->pairing_io_capabilities_ble_request.auth_req = BTM_LE_AUTH_REQ_BOND; /* Bonding required */
            TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "BTM Pairing BLE Request");
            break;

        case BTM_PAIRING_COMPLETE_EVT:
            break;

        case BTM_BLE_ADVERT_STATE_CHANGED_EVT:
            break;

        default:
            //TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "BTM Other: 0x%x", event);
            break;
    }

    return ( status );
}


#define FIND_DEVICE_ADDRESS              1
#define FIND_DEVICE_CONN_ID              2

static ble_device_data* find_device_in_array(uint8_t find_device_char, void* data)
{
	switch (find_device_char) {
		case FIND_DEVICE_ADDRESS:
			for(unsigned int i=0;i<MAX_DEVICE_DISCOVER;++i) {
				if(memcmp(s_bleScanResults[i].device_address, (uint8_t *)data, 6) == 0) {
					return &(s_bleScanResults[i]);
				}
			}
			break;
		case FIND_DEVICE_CONN_ID:
			for(unsigned int i=0;i<MAX_DEVICE_DISCOVER;++i) {
				if(s_bleScanResults[i].conn_id == *(uint16_t *)data) {
					return &(s_bleScanResults[i]);
				}
			}
			break;
		default:
			return NULL;
	}
	TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Did not match device");
	return NULL;
}

static wiced_bt_gatt_status_t ble_gatt_event_callback(wiced_bt_gatt_evt_t event, wiced_bt_gatt_event_data_t *p_event_data)
{
	wiced_bt_gatt_status_t status = WICED_BT_GATT_SUCCESS;
	wiced_bt_gatt_discovery_param_t p_discovery_param;
	ble_device_data *device;

	static uint16_t service_start_handle, service_end_handle, temp_handle;
	static bool found_descriptor = false;

	switch (event) {
		case GATT_CONNECTION_STATUS_EVT:
			device = find_device_in_array(FIND_DEVICE_ADDRESS, p_event_data->connection_status.bd_addr);
			if (device == NULL) return WICED_BT_GATT_NOT_FOUND;
			if(p_event_data->connection_status.connected == WICED_TRUE) {
				device->flags |= BLE_DEVICE_FLAG_CONNECTED;
				device->conn_id = p_event_data->connection_status.conn_id;
				TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Device connected");

				memset( &p_discovery_param, 0, sizeof(wiced_bt_gatt_discovery_param_t) );
				p_discovery_param.s_handle = 1;
				p_discovery_param.e_handle = 0xFFFF;
				p_discovery_param.uuid.len = 2;
				p_discovery_param.uuid.uu.uuid16 = HEART_RATE_SERVICE_GATT_UUID;
				status = wiced_bt_gatt_send_discover(device->conn_id, GATT_DISCOVER_SERVICES_BY_UUID, &p_discovery_param);
			} else {
				device->flags &= ~BLE_DEVICE_FLAG_CONNECTED;
				device->conn_id = 0;
				TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Device disconnected");
			}
			device->flags &= ~BLE_DEVICE_FLAG_CONNECTING;
			break;
		case GATT_DISCOVERY_RESULT_EVT:
			device = find_device_in_array(FIND_DEVICE_CONN_ID, &(p_event_data->discovery_result.conn_id));
			if (device == NULL) return WICED_BT_GATT_NOT_FOUND;
			if(p_event_data->discovery_result.discovery_type == GATT_DISCOVER_SERVICES_BY_UUID) {
			 	service_start_handle = GATT_DISCOVERY_RESULT_SERVICE_START_HANDLE(p_event_data);
			 	service_end_handle = GATT_DISCOVERY_RESULT_SERVICE_END_HANDLE(p_event_data);
			} else if (p_event_data->discovery_result.discovery_type == GATT_DISCOVER_CHARACTERISTICS) {
				if( (GATT_DISCOVERY_RESULT_CHARACTERISTIC_UUID_LEN(p_event_data) == 2) &&
					  (GATT_DISCOVERY_RESULT_CHARACTERISTIC_UUID16(p_event_data) == HEART_RATE_CHAR_UUID) ) {
							// This is the heart rate characteristic, get the descriptor
							temp_handle = p_event_data->discovery_result.discovery_data.characteristic_declaration.handle;
						}
			} else if (p_event_data->discovery_result.discovery_type == GATT_DISCOVER_CHARACTERISTIC_DESCRIPTORS) {
				if (!found_descriptor && p_event_data->discovery_result.discovery_data.char_descr_info.type.len == 2 &&
				               p_event_data->discovery_result.discovery_data.char_descr_info.type.uu.uuid16 == CLIENT_CONFIG_CHAR_UUID) {
						// Found the characteristic descriptor, let's now subscribe to this notification
						found_descriptor = true;
						temp_handle = p_event_data->discovery_result.discovery_data.char_descr_info.handle;
				}
			}
			break;
		case GATT_DISCOVERY_CPLT_EVT:
			if(p_event_data->discovery_complete.disc_type == GATT_DISCOVER_SERVICES_BY_UUID) {
				memset( &p_discovery_param, 0, sizeof(p_discovery_param) );
				p_discovery_param.s_handle = service_start_handle;
				p_discovery_param.e_handle = service_end_handle;
				status = wiced_bt_gatt_send_discover(p_event_data->discovery_complete.conn_id, GATT_DISCOVER_CHARACTERISTICS, &p_discovery_param);
			} else if (p_event_data->discovery_complete.disc_type == GATT_DISCOVER_CHARACTERISTICS ) {
        /* Charactertics have been found. Discover Descriptors */
				memset( &p_discovery_param, 0, sizeof(p_discovery_param) );
				p_discovery_param.s_handle = temp_handle;
				p_discovery_param.e_handle = service_end_handle;
				p_discovery_param.uuid.len = 2;
				p_discovery_param.uuid.uu.uuid16 = HEART_RATE_CHAR_UUID;
				status = wiced_bt_gatt_send_discover(p_event_data->discovery_complete.conn_id, GATT_DISCOVER_CHARACTERISTIC_DESCRIPTORS, &p_discovery_param);
			} else if (p_event_data->discovery_complete.disc_type == GATT_DISCOVER_CHARACTERISTIC_DESCRIPTORS ) {
        /* All characteristic descriptors have been found.
          It is now time to write to the Client Characteristic Configuration
          in order to enable notifications from the device */
				wiced_bt_gatt_value_t write_data;
				write_data.auth_req = GATT_AUTH_REQ_NONE;
				write_data.handle = temp_handle;
				write_data.len = 2;
				write_data.value[0] = 0x0001;   // Enable notifications
				status = wiced_bt_gatt_send_write(p_event_data->discovery_result.conn_id, GATT_WRITE, &write_data);
				found_descriptor = false;			// Reset it for the next device
			}
			break;
		case GATT_OPERATION_CPLT_EVT:
      if ( p_event_data->operation_complete.op == GATTC_OPTYPE_WRITE ) {
			   device = find_device_in_array(FIND_DEVICE_CONN_ID, &(p_event_data->operation_complete.conn_id));
      } else if (p_event_data->operation_complete.op == GATTC_OPTYPE_NOTIFICATION) {
         device = find_device_in_array(FIND_DEVICE_CONN_ID, &(p_event_data->operation_complete.conn_id));
         if (device == NULL) return WICED_BT_GATT_NOT_FOUND;
         uint8_t* pdata = p_event_data->operation_complete.response_data.att_value.p_data;
         if( (*pdata & 0x01) == 0) {
           memcpy(&(device->hr),pdata+1,1);
         } else {
           memcpy(&(device->hr),pdata+1,2);
         }
      }
      break;
		default:
			break;
	}
	return status;
}


bool bleSensor_thread_init( void )
{
    struct ltrx_thread *st_bt_thread;
    st_bt_thread = ltrx_thread_create("BT Gateway", bt_thread_func, NULL,
        STACK_SIZE_GREEN_FROM_MAX_OBSERVED_STACK_USED(BLE_WIFI_INT_STACK_USED));

    if(st_bt_thread == NULL)
    {
        TLOG(TLOG_SEVERITY_LEVEL__ERROR, "Failed to create st_bt_thread.");
        return false;
    }

    return true;
}

static void checkForHrSensorScanned(unsigned int i)
{
	if( (s_bleScanResults[i].appearance & 0xFFFE) == 0x0340 && !(s_bleScanResults[i].flags & BLE_DEVICE_FLAG_CONNECTING) ) {
		s_bleScanResults[i].flags |= BLE_DEVICE_FLAG_CONNECTING;

    TLOG(TLOG_SEVERITY_LEVEL__DEBUG, "Going to connect index %d %02X:%02X:%02X:%02X:%02X:%02X",
            i,
            s_bleScanResults[i].device_address[0],
            s_bleScanResults[i].device_address[1],
            s_bleScanResults[i].device_address[2],
            s_bleScanResults[i].device_address[3],
            s_bleScanResults[i].device_address[4],
            s_bleScanResults[i].device_address[5]
          );
		struct ble_message message = {
			.command = BLE_MESSAGE_CONNECT,
			.device = &s_bleScanResults[i]
		};
		new_message(ble_queue, &message, sizeof(struct ble_message));
		ltrx_trigger_signal(&ble_queue_trigger);
	}
}

static void ble_scan_callback(wiced_bt_ble_scan_results_t *result, uint8_t *p_adv_data)
{
	if (result != NULL) {
		for(unsigned int i=0;i<MAX_DEVICE_DISCOVER;++i) {
			if((s_bleScanResults[i].flags & BLE_DEVICE_FLAG_INUSE) && (memcmp(result->remote_bd_addr,s_bleScanResults[i].device_address,6) == 0) ) {
				//TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Scanned name: %s index: %d",s_bleScanResults[i].dev_name, i);
				s_bleScanResults[i].flags |= BLE_DEVICE_FLAG_SCANNED;
				checkForHrSensorScanned(i);
				return;
			}
		}
		for(unsigned int i=0;i<MAX_DEVICE_DISCOVER;++i) {
			if(!(s_bleScanResults[i].flags & BLE_DEVICE_FLAG_INUSE)) {

				uint8_t data_size;
				uint8_t *adv_data;
        adv_data = wiced_bt_ble_check_advertising_data(p_adv_data,BTM_BLE_ADVERT_TYPE_APPEARANCE,&data_size);
        memcpy(&s_bleScanResults[i].appearance,adv_data,data_size);
        if( (s_bleScanResults[i].appearance & 0xFFFE) == 0x0340 ) {  // Only add HR devices
          memcpy(s_bleScanResults[i].device_address,result->remote_bd_addr, BD_ADDR_LEN);
          s_bleScanResults[i].rssi = result->rssi;
          s_bleScanResults[i].addr_type = result->ble_addr_type;
          adv_data = wiced_bt_ble_check_advertising_data(p_adv_data,BTM_BLE_ADVERT_TYPE_NAME_COMPLETE,&data_size);
   				memcpy(&s_bleScanResults[i].dev_name,adv_data,data_size);
   				s_bleScanResults[i].flags |= BLE_DEVICE_FLAG_INUSE;
   				s_bleScanResults[i].flags |= BLE_DEVICE_FLAG_SCANNED;
   				checkForHrSensorScanned(i);
        }
				break;
			}
		}
	} else { // This is the last scan
		for(unsigned int i=0;i<MAX_DEVICE_DISCOVER;++i) {
			if( (s_bleScanResults[i].flags & BLE_DEVICE_FLAG_INUSE) &&
					!(s_bleScanResults[i].flags & BLE_DEVICE_FLAG_SCANNED) &&
					!(s_bleScanResults[i].flags & BLE_DEVICE_FLAG_CONNECTED) &&
					!(s_bleScanResults[i].flags & BLE_DEVICE_FLAG_CONNECTING)
				) {
        /* Remove devices that have not been seen since the last scan.
          Exclude those we are connected or connecting to, as those do
          not respond to scan requests */
				memset(&s_bleScanResults[i],0x00, sizeof(ble_device_data));
			} else {
				s_bleScanResults[i].flags &= ~BLE_DEVICE_FLAG_SCANNED;
			}
		}
	}
}

/*static void check_connection(void* opaque)
{
	struct ble_device_data *device = opaque;

	ltrx_thread_sleep(5000);
	if( (device->flags & BLE_DEVICE_FLAG_CONNECTING) && !(device->flags & BLE_DEVICE_FLAG_CONNECTED) ) {
		device->flags &= ~BLE_DEVICE_FLAG_CONNECTING;
	}
}
*/

static void bt_thread_func(void *arg)
{
    (void)arg;
    wiced_result_t result = WICED_SUCCESS;
    uint8_t principalInterface = (
#if MAX_NETS_ETHERNET > 0
        NETS_ETHERNET_START
#elif MAX_NETS_WLAN > 0
        NETS_WLAN_START
#else
        0
#endif
    );

    ltrx_bt_init();

    ltrx_platform_get_serial_number((char *)g_bluetooth_data->dev_info.dev_sn, sizeof(g_bluetooth_data->dev_info.dev_sn));
    strcpy((char *)g_bluetooth_data->dev_info.dev_name, (const char *)BT_DEVICE_NAME_PREFIX);
    strcat((char *)g_bluetooth_data->dev_info.dev_name, (const char *)"_");
    strcat((char *)g_bluetooth_data->dev_info.dev_name, (const char *)g_bluetooth_data->dev_info.dev_sn);

    memcpy(&g_bluetooth_data->bt_config_settings, &wiced_bt_cfg_settings, sizeof(wiced_bt_cfg_settings));
		g_bluetooth_data->bt_config_settings.device_name = g_bluetooth_data->dev_info.dev_name;

    if(
        ! ltrx_network_get_mac_address(
            principalInterface,
            g_bluetooth_data->dev_info.dev_mac,
            sizeof(g_bluetooth_data->dev_info.dev_mac)
        )
    )
    {
        TLOG(TLOG_SEVERITY_LEVEL__CRITICAL, "Failed to get MAC address.");
        return;
    }

    /* Register call back and configuration with stack */
    result = wiced_bt_stack_init( ble_gateway_management_callback ,
                        &g_bluetooth_data->bt_config_settings, wiced_bt_cfg_buf_pools );

    if(result == WICED_SUCCESS)
    {
        TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Bluetooth MAC Address %02X:%02X:%02X:%02X:%02X:%02X",
            g_bluetooth_data->dev_info.dev_mac[0],
            g_bluetooth_data->dev_info.dev_mac[1],
            g_bluetooth_data->dev_info.dev_mac[2],
            g_bluetooth_data->dev_info.dev_mac[3],
            g_bluetooth_data->dev_info.dev_mac[4],
            g_bluetooth_data->dev_info.dev_mac[5]);

				struct ble_message message;
				bool trigger_return;
        while(1) {
					trigger_return = LTRX_TRIGGER_WAIT(&ble_queue_trigger, SCAN_WAIT_INTERVAL);
					if( trigger_return ) {
						ltrx_trigger_clear(&ble_queue_trigger);
						while(get_message(ble_queue, &message)) {
							switch (message.command) {
								case BLE_MESSAGE_CONNECT:
									wiced_bt_gatt_le_connect((message.device)->device_address, (message.device)->addr_type, BLE_CONN_MODE_HIGH_DUTY, WICED_TRUE);
									//ltrx_thread_create("Check connect", check_connection, message.device, 1000);
									TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "BLE Connecting to %s", (message.device)->dev_name);
									break;
								default:
									TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Message command: %02X device name %s", message.command, (message.device)->dev_name);
								break;
							}
						}
					} else {
						wiced_bt_ble_scan(BTM_BLE_SCAN_TYPE_HIGH_DUTY, WICED_TRUE, ble_scan_callback);
					}
        }
    }
    else
    {
        TLOG(TLOG_SEVERITY_LEVEL__ERROR, "Bluetooth stack initialization failed");
    }
}

void bleSensor_module_registration(void)
{
    //uint8_t sku = ltrx_platform_get_sku();

  /*  if(
        sku == VARDEF_ENUM_OEM_SKU__XPC250100 ||
        sku == VARDEF_ENUM_OEM_SKU__XPC250200
    )*/
    {
        ltrx_module_register(&g_bleSensorModuleInfo);
        s_isBtEnabled = true;
    }
}

void bleSensor_module_startup(void)
{
    if(s_isBtEnabled)
    {
				ble_queue = init_queue();
				ltrx_trigger_create(&ble_queue_trigger, "BLE Trigger");
        enableRestApi();
        bleSensor_start();
    }
}

void bleSensor_module_shutdown(void)
{
}
